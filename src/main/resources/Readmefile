DocQA - Document Ingestion and Q&A API
Overview
DocQA is a Spring Boot-based RESTful API designed for efficient document ingestion, storage, and question-answering (Q&A) capabilities. It supports scalable document processing, full-text search, and secure access, making it ideal for applications requiring robust document management and query processing. The API is built to integrate seamlessly with external systems (e.g., .NET Core backends) and is optimized for performance and scalability.
Features

Document Ingestion:
Asynchronous single and batch document uploads via REST endpoints.
Supports metadata (title, author, type, keywords) for enhanced document organization.
Decoupled ingestion using RabbitMQ for load distribution.
Batch processing with Spring Batch for handling large document sets.


Q&A Functionality:
Full-text search powered by PostgreSQL’s tsvector and tsquery for high-performance querying.
Caching of frequent queries using Redis to improve response times.


Security:
JWT-based authentication with role-based access control (ADMIN, EDITOR, VIEWER).
Token blacklisting for secure logout.


Scalability:
Retry mechanisms with exponential backoff using Spring Retry.
Message queues (RabbitMQ) for distributed task processing.
Dockerized setup for easy deployment and scaling.


API Documentation:
Swagger/OpenAPI integration for interactive API exploration.


Testing:
Unit tests with Mockito for core services (Auth, Document, Q&A).



Technologies Used

Backend Framework: Spring Boot 3.2.5 (Java 17)
Database: PostgreSQL 16 with tsvector for full-text search
Message Queue: RabbitMQ 3 for asynchronous task processing
Caching: Redis 7 for query result caching
Batch Processing: Spring Batch 5.x for large-scale document ingestion
Security: Spring Security with JJWT 0.9.1 for JWT authentication
API Documentation: Springdoc OpenAPI 2.5.0 for Swagger UI
Testing: JUnit 5, Mockito for unit tests
Build Tool: Maven
Containerization: Docker with Docker Compose for multi-service orchestration
Logging: SLF4J with Logback for structured logging
Retry Mechanism: Spring Retry for robust error handling
Dependencies:
spring-boot-starter-web
spring-boot-starter-data-jpa
spring-boot-starter-security
spring-boot-starter-batch
spring-boot-starter-data-redis
spring-boot-starter-amqp
postgresql
jjwt
springdoc-openapi-starter-webmvc-ui



Project Structure
src/main/java/com/App/Spring/Boot/Docs/QnA/
├── batch/                    # Spring Batch components for document processing
├── config/                   # Configuration classes (Async, Batch, Redis, RabbitMQ, Security, Swagger)
├── controller/               # REST controllers for Auth, Document, and Q&A endpoints
├── dto/                      # Data Transfer Objects for API payloads
├── entity/                   # JPA entities (Document, User, TokenBlacklist)
├── exception/                # Custom exceptions (e.g., DocumentProcessingException)
├── messaging/                # RabbitMQ message listeners
├── repository/               # JPA repositories for database operations
├── security/                 # JWT utilities and filters
├── service/                  # Business logic for Auth, Document, and Q&A
└── DocQaApplication.java     # Main application entry point

src/main/resources/
├── application.properties    # Configuration for database, RabbitMQ, Redis, etc.
├── database.sql              # PostgreSQL full-text search setup
└── docker/                   # Dockerfile and docker-compose.yml

src/test/java/                # Unit tests for services

Prerequisites

Java 17
Maven 3.8+
Docker and Docker Compose
PostgreSQL 16
RabbitMQ 3
Redis 7

Setup Instructions

Clone the Repository:
git clone https://github.com/your-username/docqa.git
cd docqa


Configure Environment:

Update src/main/resources/application.properties with your credentials:spring.datasource.url=jdbc:postgresql://localhost:5432/docs
spring.datasource.username=postgres
spring.datasource.password=your_password
spring.rabbitmq.host=localhost
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.redis.host=localhost
spring.redis.port=6379


Update SECRET_KEY in JwtUtil.java for production:private String SECRET_KEY = "your-secure-256-bit-secret-key";




Start Dependencies with Docker:
docker-compose -f src/main/resources/docker/docker-compose.yml up -d

This starts PostgreSQL, RabbitMQ, and Redis. PostgreSQL initializes full-text search via initdb/01_init.sql.

Build the Project:
mvn clean package


Run the Application:
java -jar target/docqa-0.0.1-SNAPSHOT.jar

Or use Docker:
docker-compose -f src/main/resources/docker/docker-compose.yml up --build


Access the API:

Swagger UI: http://localhost:8080/swagger-ui.html
RabbitMQ Management: http://localhost:15672 (default credentials: guest/guest)



API Endpoints

Authentication:
POST /api/v1/auth/register - Register a user (requires username, password, roles)
POST /api/v1/auth/login - Login and receive JWT token
POST /api/v1/auth/logout - Blacklist JWT token (requires Bearer token)


Document Ingestion:
POST /api/v1/documents/ingest - Ingest a single document (queues via RabbitMQ)
POST /api/v1/documents/ingest/batch - Ingest multiple documents using Spring Batch
GET /api/v1/documents?author={author}&type={type}&page={page}&size={size} - Retrieve documents by metadata


Q&A:
POST /api/v1/qna - Submit a question and receive matching documents (cached in Redis)



Example: Batch Ingestion Request
POST http://localhost:8080/api/v1/documents/ingest/batch
Authorization: Bearer <jwt-token>
[
    {
        "title": "Test Doc 1",
        "content": "Sample content 1",
        "author": "Author 1",
        "type": "PDF",
        "keywords": ["test", "doc"]
    },
    {
        "title": "Test Doc 2",
        "content": "Sample content 2",
        "author": "Author 2",
        "type": "PDF",
        "keywords": ["test", "doc"]
    }
]

Running Tests
Execute unit tests with:
mvn test

Tests cover AuthService, DocumentService, and QnaService using Mockito.
Deployment

Build the Docker image:docker build -t docqa:latest -f src/main/resources/docker/Dockerfile .


Deploy using Docker Compose or a Kubernetes cluster.
Configure a CI/CD pipeline (e.g., GitHub Actions) for automated builds and deployments.

Contributing

Fork the repository.
Create a feature branch: git checkout -b feature/your-feature.
Commit changes: git commit -m "Add your feature".
Push to the branch: git push origin feature/your-feature.
Open a pull request.

Notes

Security: Update JWT SECRET_KEY and database credentials for production.
Scalability: Adjust ThreadPoolTaskExecutor and RabbitMQ queue settings based on load.
Enhancements: Consider integrating Elasticsearch for advanced search or adding integration tests for batch jobs.
Monitoring: Use RabbitMQ management UI and Spring Boot Actuator for monitoring.
